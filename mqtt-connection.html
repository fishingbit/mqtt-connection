<link rel="import" href="../polymer/polymer-element.html">

<dom-module id="mqtt-connection">
    <script src="./paho.mqtt.javascript/1.0.4/paho-mqtt.js"></script>

    <script>
        /**
         * `mqtt-connection` Creates a Connection to the MQTT Broker. Automatically (re)connects and handles
         * subscriptions with callbacks. Uses the Eclipse Paho JavaScript client.
         *
         * @customElement
         * @polymer
         */
        class MqttConnection extends Polymer.Element {
            static get is() { return 'mqtt-connection'; }
            static get properties() {
                return {
                    /**
                     *  Hostname or IP Address of the MQTT Broker.
                     */
                    host: {
                        type: String
                    },
                    /**
                     *  Port Number of the MQTT Broker.
                     */
                    port: {
                        type: Number
                    },
                    /**
                     * The protocol to use for the connection to the MQTT Broker. Has to be `ws` or `wss`.
                     */
                    protocol: {
                        type: String,
                        value: 'ws'
                    },
                    username: {
                        type: String,
                        value: ''
                    },
                    password: {
                        type: String,
                        value: ''
                    },
                    /**
                     *  The MQTT Client id. Will be suffixed with a random 8 digit hex number.
                     */
                    clientId: {
                        type: String,
                        value: 'polymer'
                    },
                    /**
                     *  Seconds.
                     */
                    keepAliveInterval: {
                        type: Number,
                        value: 10
                    },

                    /**
                     * Indicates if connected to the mqtt broker.
                     */
                    connected: {
                        type: Boolean,
                        readOnly: true,
                        notify: true,
                        value: false,
                        reflectToAttribute: true
                    },
                    /**
                     * Fired when `mqtt-connection` changes its connected state.
                     *
                     * @event connected-changed
                     * @param {boolean} Indicates if connected to the mqtt broker.
                     */

                    /**
                     *  Seconds to wait between connection retries.
                     */
                    reconnectInterval: {
                        type: Number,
                        value: 1
                    },
                    /**
                     * Topic for the Last-Will/Testament action (published by the broker after this client disconnected).
                     */
                    willTopic: {
                        type: String
                    },
                    willPayload: {
                        type: String
                    },
                    willRetain: {
                        type: Boolean
                    }
                }
            }

            connectedCallback() {
                super.connectedCallback();
                const that = this;

                this.__subscriptions = {};
                this.__subscriptionId = 0;
                const clientIdSuffix = '_' + ('00000000' + Math.floor(Math.random() * 0xffffffff).toString(16)).slice(-8);
                this.__mqttClient = new Paho.MQTT.Client(this.host, this.port, this.clientId + clientIdSuffix);

                const connectOptions = {
                    userName: that.username,
                    password: that.password,
                    cleanSession: true,
                    useSSL: that.protocol === 'wss',
                    keepAliveInterval: that.keepAliveInterval,
                    onSuccess: () => {
                        that._setConnected(true);

                        Object.keys(that.__subscriptions).forEach(topic => {
                            this.__mqttClient.subscribe(topic);
                        });
                    },
                    onFailure: (err) => {
                        /**
                         * Fired on MQTT connection failures
                         *
                         * @event failure
                         * @param {object} contains errorCode and errorMessage
                         */
                        that.dispatchEvent(new CustomEvent('failure', {
                            detail: {errorCode: err.errorCode, errorMessage: err.errorMessage},
                            bubbles: true,
                            composed: true
                        }));
                        setTimeout(connect, that.reconnectInterval * 1000);
                    }
                };

                if (typeof this.willTopic !== 'undefined') {
                    connectOptions.willMessage = new Paho.MQTT.Message(String(this.willPayload));
                    connectOptions.willMessage.destinationName = this.willTopic;
                    connectOptions.willMessage.retained = Booelan(this.willRetain);
                }

                const connect = () => {
                    this.__mqttClient.connect(connectOptions);
                };

                connect();

                this.__mqttClient.onConnectionLost = responseObject => {
                    that._setConnected(false);
                    setTimeout(connect, this.reconnectInterval);
                };

                this.__mqttClient.onMessageArrived = msg => {
                    Object.keys(that.__subscriptions).forEach(topic => {
                        if (topic === msg.destinationName) {
                            Object.keys(that.__subscriptions[topic]).forEach(id => {
                                const callback = that.__subscriptions[topic][id].callback;
                                callback(msg.payloadString);
                            });
                        }
                    });
                };
            }

            /**
             *
             * @param topic
             * @param payload
             * @param options
             * @param callback
             */
            publish(topic, payload, options, callback) {
                if (typeof options === 'function') {
                    callback = options;
                    options = {};
                } else if (typeof options !== 'object') {
                    options = {}
                }
                if (this.connected) {
                    if (typeof payload === 'object') {
                        payload = JSON.stringify(payload);
                    } else if (typeof payload !== 'string') {
                        payload = String(payload);
                    }
                    this.__mqttClient.send(topic, payload, parseInt(options.qos, 10) || 0, Boolean(options.retain));
                    if (typeof callback === 'function') {
                        callback(null);
                    }
                } else {
                    if (typeof callback === 'function') {
                        callback(new Error('not connected'));
                    }
                }
            }

            /**
             *  @param {string} topic
             *  @param {function} callback
             *  @returns {subscriptionId} subscriptionId
             */
            subscribe(topic, callback) {
                this.__subscriptionId += 1;
                if (this.__subscriptions[topic]) {
                    this.__subscriptions[topic]['s' + this.__subscriptionId] = {callback};
                } else {
                    this.__subscriptions[topic] = {};
                    this.__subscriptions[topic]['s' + this.__subscriptionId] = {callback};
                    if (this.connected) {
                        this.__mqttClient.subscribe(topic);
                    }
                }
                return {id: this.__subscriptionId, topic};
            }

            /**
             *  Unsubscribe from a previously subscribed topic. Supply the subscriptionId returned by the subscribe
             *  method.
             *
             *  @param {subscriptionId} subscriptionId
             */
            unsubscribe(subscription) {
                if (this.__subscriptions[subscription.topic]) {
                    delete this.__subscriptions[subscription.topic]['s' + subscription.id];
                    if (Object.keys(this.__subscriptions[subscription.topic]).length === 0) {
                        this.__mqttClient.unsubscribe(subscription.topic);
                        delete this.__subscriptions[subscription.topic];
                    }
                }
            }
        }

        customElements.define(MqttConnection.is, MqttConnection);
    </script>
</dom-module>